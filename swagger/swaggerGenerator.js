const fs = require('fs');
const path = require('path');

class SwaggerGenerator {
  static generateSwaggerJson(project, endpoints) {
    const swaggerDoc = {
      openapi: '3.0.3',
      info: {
        title: project.name,
        description: project.description || 'API Documentation generated by Swagger Manager',
        version: '1.0.0',
        contact: {
          name: 'API Support',
          url: 'http://localhost:3000'
        }
      },
      servers: [
        {
          url: 'http://localhost:5000',
          description: 'Development server'
        },
        {
          url: 'https://your-production-url.com/api',
          description: 'Production server (update this URL)'
        }
      ],
      paths: {},
      components: {
        schemas: {},
        securitySchemes: {
          bearerAuth: {
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'JWT',
            description: 'Enter JWT token with "Bearer " prefix'
          },
          apiKey: {
            type: 'apiKey',
            in: 'header',
            name: 'X-API-Key',
            description: 'API Key authentication'
          }
        }
      },
      tags: []
    };

    // Build paths from endpoints
    endpoints.forEach(endpoint => {
      if (!swaggerDoc.paths[endpoint.path]) {
        swaggerDoc.paths[endpoint.path] = {};
      }

      const operation = {
        summary: endpoint.summary,
        description: endpoint.description || '',
        tags: endpoint.tags.length > 0 ? endpoint.tags : ['default'],
        parameters: this.buildParameters(endpoint.parameters),
        responses: this.buildResponses(endpoint.responses),
        deprecated: endpoint.deprecated
      };

      // Add request body if exists
      if (endpoint.requestBody && endpoint.requestBody.content) {
        operation.requestBody = {
          description: endpoint.requestBody.description || '',
          required: endpoint.requestBody.required || false,
          content: Object.fromEntries(endpoint.requestBody.content)
        };
      }

      // Add security if specified
      if (endpoint.security && endpoint.security.length > 0) {
        operation.security = endpoint.security.map(sec => ({ [sec]: [] }));
      }

      swaggerDoc.paths[endpoint.path][endpoint.method.toLowerCase()] = operation;

      // Add tags to document
      endpoint.tags.forEach(tag => {
        if (!swaggerDoc.tags.some(t => t.name === tag)) {
          swaggerDoc.tags.push({ 
            name: tag, 
            description: `${tag.charAt(0).toUpperCase() + tag.slice(1)} operations` 
          });
        }
      });
    });

    // Add default tag if none exists
    if (swaggerDoc.tags.length === 0) {
      swaggerDoc.tags.push({ name: 'default', description: 'Default operations' });
    }

    return swaggerDoc;
  }

  static buildParameters(parameters) {
    if (!parameters || parameters.length === 0) return [];

    return parameters.map(param => ({
      name: param.name,
      in: param.in,
      description: param.description || '',
      required: param.required || false,
      schema: {
        type: param.schema?.type || 'string'
      }
    }));
  }

  static buildResponses(responses) {
    if (!responses || responses.size === 0) {
      return {
        '200': {
          description: 'Successful response',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                example: { message: 'Success' }
              }
            }
          }
        }
      };
    }

    const result = {};
    responses.forEach((value, key) => {
      result[key] = {
        description: value.description || `${key} response`,
        content: value.content ? Object.fromEntries(value.content) : {
          'application/json': {
            schema: { type: 'object' }
          }
        }
      };
    });
    return result;
  }

  static saveSwaggerFile(projectId, swaggerJson) {
    const dir = path.join(__dirname, '../swagger-files');
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    const filePath = path.join(dir, `${projectId}.json`);
    fs.writeFileSync(filePath, JSON.stringify(swaggerJson, null, 2));
    console.log(`âœ… Swagger file saved: ${filePath}`);
    return filePath;
  }

  static getSwaggerFile(projectId) {
    const filePath = path.join(__dirname, '../swagger-files', `${projectId}.json`);
    if (fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    }
    return null;
  }
}

module.exports = SwaggerGenerator;